#include <xtensa/hal.h>
#include <xtensa/config/core.h>
#include <xtensa/config/system.h>
#include "./diag_utils.h"
#include "./ip_common.h"
#include "./saradc_reg.h"
#include "./rtc_cntl_reg.h"
#include "./rtc_mem_reg.h"
#include "./rtc_io_reg.h"
#include "./timers_reg.h"
#include "./apb_ctrl_reg.h"
#include "./sys_timer_reg.h"
#include "./interrupt_reg.h"
#include "./system_reg.h"
#include "./i2c_mst_reg.h"
#include "./i2c_define.h"

typedef enum {False, True} bool;

void rtc_check_idle();

void rtc_init();

void rtc_slp(u8 mode, u32 wakeup_opt, u32 reject_opt);

void rtc_slp_timer(u32 slp_cycle, u8 mode);

u32 rtc_fastmem_crc();

void rtc_pad_init();

void rtc_pad_input(u32 pad_num);

void rtc_fast_clk_switch(u8 fast_clk_sel);

u32 rtc_clk_cali(u8 clk_sel, u32 timeout);

void cpu_freq_set(u8 source, u8 div);

void rtc_8m_en(u8 div);

void rtc_32k_en(bool init_clk);

u32 rtc_tsens(u32 wait_delay, u32 clk_div, u32 meas_delay);

void rtc_check_ulp_done();

u32 rtc_touch(u32 pad, u32 thres, u32 delay);

u32 rtc_saradc1(u8 chn, u8 div);

u32 rtc_saradc2(u8 chn, u8 div);

void rtc_slow_clk_delay();

#define RTC_FASTMEM_BASE   0x3ff9e000
#define RTC_FASTMEM_I_BASE 0x40070000

//sleep related
void rtc_check_idle()
{
	while (1)
	{
		if (GET_PERI_REG_BITS(RTC_LOW_POWER_ST, RTC_CNTL_RTC_MAIN_STATE, RTC_CNTL_RTC_MAIN_STATE_S) == 0x0) break;
	}
}

void rtc_init()
{
	// clear rtc wdt
	CLEAR_PERI_REG_MASK(RTC_WDTCONFIG0, RTC_CNTL_WDT_EN);
	CLEAR_PERI_REG_MASK(RTC_TIME_UPDATE, RTC_CNTL_TIMER_XTL_OFF);
	CLEAR_PERI_REG_MASK(RTC_TIME_UPDATE, RTC_CNTL_TIMER_SYS_RST);
	CLEAR_PERI_REG_MASK(RTC_TIME_UPDATE, RTC_CNTL_TIMER_SYS_STALL);

	// power state should be fast
	SET_PERI_REG_BITS(RTC_TIMER3, RTC_CNTL_ROM_RAM_POWERUP_TIMER, 1, RTC_CNTL_ROM_RAM_POWERUP_TIMER_S);
	SET_PERI_REG_BITS(RTC_TIMER3, RTC_CNTL_ROM_RAM_WAIT_TIMER, 1, RTC_CNTL_ROM_RAM_WAIT_TIMER_S);
	SET_PERI_REG_BITS(RTC_TIMER3, RTC_CNTL_WIFI_POWERUP_TIMER, 1, RTC_CNTL_WIFI_POWERUP_TIMER_S);
	SET_PERI_REG_BITS(RTC_TIMER3, RTC_CNTL_WIFI_WAIT_TIMER, 1, RTC_CNTL_WIFI_WAIT_TIMER_S);
	SET_PERI_REG_BITS(RTC_TIMER4, RTC_CNTL_DG_WRAP_POWERUP_TIMER, 1, RTC_CNTL_DG_WRAP_POWERUP_TIMER_S);
	SET_PERI_REG_BITS(RTC_TIMER4, RTC_CNTL_DG_WRAP_WAIT_TIMER, 1, RTC_CNTL_DG_WRAP_WAIT_TIMER_S);
	SET_PERI_REG_BITS(RTC_TIMER4, RTC_CNTL_RTC_POWERUP_TIMER, 1, RTC_CNTL_RTC_POWERUP_TIMER_S);
	SET_PERI_REG_BITS(RTC_TIMER4, RTC_CNTL_RTC_WAIT_TIMER, 1, RTC_CNTL_RTC_WAIT_TIMER_S);
	SET_PERI_REG_BITS(RTC_TIMER5, RTC_CNTL_RTCMEM_POWERUP_TIMER, 1, RTC_CNTL_RTCMEM_POWERUP_TIMER_S);
	SET_PERI_REG_BITS(RTC_TIMER5, RTC_CNTL_RTCMEM_WAIT_TIMER, 1, RTC_CNTL_RTCMEM_WAIT_TIMER_S);
	
 	CLEAR_PERI_REG_MASK(RTC_REG, RTC_CNTL_RTC_REGULATOR_FORCE_PU);
 	CLEAR_PERI_REG_MASK(RTC_REG, RTC_CNTL_RTC_DBOOST_FORCE_PU);
 	CLEAR_PERI_REG_MASK(DIG_PWC, RTC_CNTL_LSLP_MEM_FORCE_PU);

 	CLEAR_PERI_REG_MASK(DIG_ISO, RTC_CNTL_DG_PAD_FORCE_UNHOLD);
	CLEAR_PERI_REG_MASK(DIG_ISO, RTC_CNTL_DG_PAD_FORCE_HOLD);
	CLEAR_PERI_REG_MASK(RTC_PWC, RTC_CNTL_RTC_PAD_FORCE_HOLD);

	CLEAR_PERI_REG_MASK(DIG_ISO, RTC_CNTL_DG_PAD_FORCE_ISO);
	CLEAR_PERI_REG_MASK(DIG_ISO, RTC_CNTL_DG_PAD_FORCE_NOISO);

 	CLEAR_PERI_REG_MASK(RTC_OPTIONS0, RTC_CNTL_BIAS_CORE_FORCE_PU);
 	CLEAR_PERI_REG_MASK(RTC_OPTIONS0, RTC_CNTL_BIAS_I2C_FORCE_PU);
 	CLEAR_PERI_REG_MASK(RTC_OPTIONS0, RTC_CNTL_BIAS_FORCE_NOSLEEP);

 	CLEAR_PERI_REG_MASK(RTC_OPTIONS0, RTC_CNTL_XTL_FORCE_PU);
	CLEAR_PERI_REG_MASK(RTC_OPTIONS0, RTC_CNTL_BIAS_SLEEP_FOLW_8M);
	CLEAR_PERI_REG_MASK(RTC_OPTIONS0, RTC_CNTL_BIAS_I2C_FOLW_8M);

	//ulp wait
	SET_PERI_REG_BITS(RTC_TIMER2, RTC_CNTL_ULPCP_TOUCH_START_WAIT, 8, RTC_CNTL_ULPCP_TOUCH_START_WAIT_S);

	//clear pad autohold
	SET_PERI_REG_MASK(DIG_ISO, RTC_CNTL_CLR_DG_PAD_AUTOHOLD);
	//set auto hold enable
	SET_PERI_REG_MASK(DIG_ISO, RTC_CNTL_DG_PAD_AUTOHOLD_EN);

	//clear force signals
	CLEAR_PERI_REG_MASK(DIG_PWC, RTC_CNTL_DG_WRAP_FORCE_PU);
	CLEAR_PERI_REG_MASK(DIG_PWC, RTC_CNTL_DG_WRAP_FORCE_PD);
	CLEAR_PERI_REG_MASK(DIG_ISO, RTC_CNTL_DG_WRAP_FORCE_NOISO);

	CLEAR_PERI_REG_MASK(RTC_PWC, RTC_CNTL_RTC_FORCE_PU);
	CLEAR_PERI_REG_MASK(RTC_PWC, RTC_CNTL_RTC_FORCE_PD);
	CLEAR_PERI_REG_MASK(RTC_PWC, RTC_CNTL_RTC_FORCE_NOISO);

	CLEAR_PERI_REG_MASK(DIG_PWC, RTC_CNTL_WIFI_FORCE_PU);
	CLEAR_PERI_REG_MASK(DIG_PWC, RTC_CNTL_WIFI_FORCE_PD);
	CLEAR_PERI_REG_MASK(DIG_ISO, RTC_CNTL_WIFI_FORCE_NOISO);

	CLEAR_PERI_REG_MASK(RTC_PWC, RTC_CNTL_RTC_SLOWMEM_FORCE_PU);
	CLEAR_PERI_REG_MASK(RTC_PWC, RTC_CNTL_RTC_SLOWMEM_FORCE_PD);
 	CLEAR_PERI_REG_MASK(RTC_PWC, RTC_CNTL_RTC_SLOWMEM_FORCE_NOISO);

	CLEAR_PERI_REG_MASK(RTC_PWC, RTC_CNTL_RTC_FASTMEM_FORCE_PU);
	CLEAR_PERI_REG_MASK(RTC_PWC, RTC_CNTL_RTC_FASTMEM_FORCE_PD);
	CLEAR_PERI_REG_MASK(RTC_PWC, RTC_CNTL_RTC_FASTMEM_FORCE_NOISO);

	//wait for rtc main_state==idle_state
	rtc_check_idle();
	rtc_slow_clk_delay();

	//enable 8m clk by default
	rtc_8m_en(0);
	rtc_fast_clk_switch(1);
	
	//select pll 240M
	cpu_freq_set(2, 2);

	printinfo("RTC initialized...\n",1);
}


void rtc_slp(u8 mode, u32 wakeup_opt, u32 reject_opt)
{
	//wake up option
	SET_PERI_REG_BITS(RTC_WAKEUP_STATE, RTC_CNTL_RTC_WAKEUP_ENA, wakeup_opt, RTC_CNTL_RTC_WAKEUP_ENA_S);
	SET_PERI_REG_BITS(RTC_SLP_REJECT_CONF, RTC_CNTL_RTC_SLEEP_REJECT_ENA, reject_opt, RTC_CNTL_RTC_SLEEP_REJECT_ENA_S);
	SET_PERI_REG_BITS(RTC_TIMER5, RTC_CNTL_MIN_SLP_VAL, 0x10, RTC_CNTL_MIN_SLP_VAL_S);

	//sleep mode
	if (mode & 0x1) //pd digital core
	{
		SET_PERI_REG_MASK(RTC_TIME_UPDATE, RTC_CNTL_TIMER_SYS_RST);
		SET_PERI_REG_MASK(DIG_PWC, RTC_CNTL_DG_WRAP_PD_EN);
		printinfo("Deep Sleep!\n",1);
	}
	else
	{
		SET_PERI_REG_MASK(RTC_TIME_UPDATE, RTC_CNTL_TIMER_SYS_STALL);
		CLEAR_PERI_REG_MASK(DIG_PWC, RTC_CNTL_DG_WRAP_PD_EN);
		printinfo("Light Sleep!\n",1);
	}
	if (mode & 0x2) //pd rtc_peri
	{
		SET_PERI_REG_MASK(RTC_PWC, RTC_CNTL_RTC_PD_EN);
		printinfo("rtc off\n",1);
	}
	else
	{
		CLEAR_PERI_REG_MASK(RTC_PWC, RTC_CNTL_RTC_PD_EN);
	}
	if (mode & 0x4) //pd rtc fast/slow mem
	{
		SET_PERI_REG_MASK(RTC_PWC,RTC_CNTL_RTC_SLOWMEM_PD_EN);
		SET_PERI_REG_MASK(RTC_PWC,RTC_CNTL_RTC_FASTMEM_PD_EN);
		printinfo("rtc slow/fast mem off\n",1);
	}
	else
	{
		CLEAR_PERI_REG_MASK(RTC_PWC,RTC_CNTL_RTC_SLOWMEM_PD_EN);
		CLEAR_PERI_REG_MASK(RTC_PWC,RTC_CNTL_RTC_FASTMEM_PD_EN);
	}
	if (mode & 0x8) //pd wifi
	{
		SET_PERI_REG_MASK(DIG_PWC, RTC_CNTL_WIFI_PD_EN);
		printinfo("wifi off\n",1);
	}
	else
	{
		CLEAR_PERI_REG_MASK(DIG_PWC, RTC_CNTL_WIFI_PD_EN);
	}
	//sel xtal
	cpu_freq_set(0, 0);

	//check rtc state
	rtc_check_idle();
	delay_us(300);
	//go to sleep
	SET_PERI_REG_MASK(RTC_STATE0, RTC_CNTL_SLEEP_EN);
	
	while (1)
	{
		if (GET_PERI_REG_BITS(INT_RAW_RTC, 1, RTC_CNTL_SLP_WAKEUP_INT_RAW_S) == 0x1) 
		{
			SET_PERI_REG_MASK(INT_CLR_RTC, RTC_CNTL_SLP_WAKEUP_INT_CLR);
			printinfo("light sleep wake!\n",1);
			break;
		}
		if (GET_PERI_REG_BITS(INT_RAW_RTC, 1, RTC_CNTL_SLP_REJECT_INT_RAW_S) == 0x1)
		{
			SET_PERI_REG_MASK(INT_CLR_RTC, RTC_CNTL_SLP_REJECT_INT_CLR);
			printinfo("sleep rejected!\n",1);
			break;
		}
	}
	SET_PERI_REG_MASK(INT_CLR_RTC, 0xFFFFFFFF);
}

void rtc_slp_timer(u32 slp_cycle, u8 mode)
{
	SET_PERI_REG_MASK(RTC_TIME_UPDATE,RTC_CNTL_RTC_TIME_UPDATE);
	while(GET_PERI_REG_MASK(INT_RAW_RTC, RTC_CNTL_RTC_TIME_VALID_INT_ST) == 0);
	SET_PERI_REG_MASK(INT_CLR_RTC, RTC_CNTL_RTC_TIME_VALID_INT_ST);

	u32 time = READ_PERI_REG(RTC_TIME_LOW0); 
	time = time + slp_cycle;
	WRITE_PERI_REG(RTC_SLP_TIMER0, time);
	WRITE_PERI_REG(RTC_SLP_TIMER1, 0);
      
	SET_PERI_REG_MASK(RTC_SLP_TIMER1, RTC_CNTL_RTC_MAIN_TIMER_ALARM_EN);
	rtc_slp(mode, 0x8, 0x0);
	CLEAR_PERI_REG_MASK(RTC_SLP_TIMER1, RTC_CNTL_RTC_MAIN_TIMER_ALARM_EN);
}

u32 rtc_fastmem_crc()
{	
	SET_PERI_REG_BITS(SYSTEM_RTC_FASTMEM_CONFIG_REG, SYSTEM_RTC_MEM_CRC_ADDR, 0, SYSTEM_RTC_MEM_CRC_ADDR_S);
	SET_PERI_REG_BITS(SYSTEM_RTC_FASTMEM_CONFIG_REG, SYSTEM_RTC_MEM_CRC_LEN, 0x7FF, SYSTEM_RTC_MEM_CRC_LEN_S);
	SET_PERI_REG_MASK(SYSTEM_RTC_FASTMEM_CONFIG_REG, SYSTEM_RTC_MEM_CRC_START);
	while (!GET_PERI_REG_MASK(SYSTEM_RTC_FASTMEM_CONFIG_REG, SYSTEM_RTC_MEM_CRC_FINISH)){}
	CLEAR_PERI_REG_MASK(SYSTEM_RTC_FASTMEM_CONFIG_REG, SYSTEM_RTC_MEM_CRC_START);
	u32 crc_result = READ_PERI_REG(SYSTEM_RTC_FASTMEM_CRC_REG);
	return crc_result;
}

//pad related
#define RTC_PAD_DRV			0x00000003
#define RTC_PAD_DRV_S		29
#define RTC_PAD_RDE			(BIT(28))
#define RTC_PAD_RUE			(BIT(27))
#define RTC_PAD_MUX_SEL		(BIT(19))
#define RTC_PAD_FUN_SEL		0x00000003
#define RTC_PAD_FUN_SEL_S	17
#define RTC_PAD_SLP_SEL		(BIT(16))
#define RTC_PAD_SLP_IE		(BIT(15))
#define RTC_PAD_SLP_OE		(BIT(14))
#define RTC_PAD_FUN_IE		(BIT(13))

void rtc_pad_init()
{
	u32 i;
	for (i=0; i<21; i++)
	{
		SET_PERI_REG_MASK(TOUCH_PAD0 + 4*i, RTC_PAD_SLP_SEL);
		CLEAR_PERI_REG_MASK(TOUCH_PAD0 + 4*i, RTC_PAD_RDE);
		CLEAR_PERI_REG_MASK(TOUCH_PAD0 + 4*i, RTC_PAD_RUE);
		CLEAR_PERI_REG_MASK(TOUCH_PAD0 + 4*i, RTC_PAD_SLP_IE);
		CLEAR_PERI_REG_MASK(TOUCH_PAD0 + 4*i, RTC_PAD_SLP_OE);
		CLEAR_PERI_REG_MASK(TOUCH_PAD0 + 4*i, RTC_PAD_FUN_IE);
		SET_PERI_REG_MASK(TOUCH_PAD0 + 4*i, RTC_PAD_MUX_SEL);
	}
}

void rtc_pad_input(u32 pad_num)
{
	SET_PERI_REG_MASK(TOUCH_PAD0 + 4*pad_num, RTC_PAD_SLP_SEL);
	CLEAR_PERI_REG_MASK(TOUCH_PAD0 + 4*pad_num, RTC_PAD_RDE);
	CLEAR_PERI_REG_MASK(TOUCH_PAD0 + 4*pad_num, RTC_PAD_RUE);
	SET_PERI_REG_MASK(TOUCH_PAD0 + 4*pad_num, RTC_PAD_SLP_IE);
	SET_PERI_REG_MASK(TOUCH_PAD0 + 4*pad_num, RTC_PAD_SLP_OE);
	SET_PERI_REG_MASK(TOUCH_PAD0 + 4*pad_num, RTC_PAD_FUN_IE);
	SET_PERI_REG_MASK(TOUCH_PAD0 + 4*pad_num, RTC_PAD_MUX_SEL);
}

//clk related
void cpu_freq_set(u8 source, u8 div)
{
	if (source == 0)
	{
		SET_PERI_REG_BITS(APB_CTRL_SYSCLK_CONF_REG, APB_CTRL_SOC_CLK_SEL, 0, APB_CTRL_SOC_CLK_SEL_S);
	}
	else if (source == 1)
	{
		CLEAR_PERI_REG_MASK(SYSTEM_CPU_PER_CONF_REG, SYSTEM_PLL_FREQ_SEL);
		SET_PERI_REG_BITS(SYSTEM_CPU_PER_CONF_REG, SYSTEM_CPUPERIOD_SEL, div, SYSTEM_CPUPERIOD_SEL_S);
		SET_PERI_REG_BITS(APB_CTRL_SYSCLK_CONF_REG, APB_CTRL_SOC_CLK_SEL, 1, APB_CTRL_SOC_CLK_SEL_S);
	}
	else if (source == 2)
	{
		SET_PERI_REG_MASK(SYSTEM_CPU_PER_CONF_REG, SYSTEM_PLL_FREQ_SEL);
		SET_PERI_REG_BITS(SYSTEM_CPU_PER_CONF_REG, SYSTEM_CPUPERIOD_SEL, div, SYSTEM_CPUPERIOD_SEL_S);
		SET_PERI_REG_BITS(APB_CTRL_SYSCLK_CONF_REG, APB_CTRL_SOC_CLK_SEL, 1, APB_CTRL_SOC_CLK_SEL_S);
	}
	else if (source == 3)
	{
		SET_PERI_REG_BITS(APB_CTRL_SYSCLK_CONF_REG, APB_CTRL_SOC_CLK_SEL, 2, APB_CTRL_SOC_CLK_SEL_S);
	}
	else if (source == 4)
	{
		SET_PERI_REG_BITS(APB_CTRL_SYSCLK_CONF_REG, APB_CTRL_SOC_CLK_SEL, 3, APB_CTRL_SOC_CLK_SEL_S);
	}
}

void rtc_fast_clk_switch(u8 fast_clk_sel)
{
	//switch fast clk
	SET_PERI_REG_BITS(RTC_CLK_CONF, 1, fast_clk_sel, RTC_CNTL_FAST_CLK_RTC_SEL_S);
}

void rtc_slow_clk_switch(u8 slow_clk_sel)
{
	//switch fast clk
	SET_PERI_REG_BITS(RTC_CLK_CONF,RTC_CNTL_ANA_CLK_RTC_SEL, slow_clk_sel, RTC_CNTL_ANA_CLK_RTC_SEL_S);
}

/* clk sel:
0 <= rtc slow clk
1 <= 8m256d clk
2 <= 32k xtal
*/
u32 rtc_clk_cali(u8 clk_sel, u32 timeout)
{
	CLEAR_PERI_REG_MASK(TIMERS_RTCCALICFG_REG(0), TIMERS_RTC_CALI_START_CYCLING);
	SET_PERI_REG_BITS(TIMERS_RTCCALICFG_REG(0), TIMERS_RTC_CALI_CLK_SEL, clk_sel, TIMERS_RTC_CALI_CLK_SEL_S);
	SET_PERI_REG_BITS(TIMERS_RTCCALICFG2_REG(0), TIMERS_RTC_CALI_TIMEOUT_THRES, timeout,TIMERS_RTC_CALI_TIMEOUT_THRES_S);
	SET_PERI_REG_BITS(TIMERS_RTCCALICFG_REG(0), TIMERS_RTC_CALI_MAX, 20, TIMERS_RTC_CALI_MAX_S);
	SET_PERI_REG_MASK(TIMERS_RTCCALICFG_REG(0), TIMERS_RTC_CALI_START);
	delay_us(5);

	while(GET_PERI_REG_MASK(TIMERS_RTCCALICFG_REG(0),TIMERS_RTC_CALI_RDY)==0)
	{
		if(GET_PERI_REG_MASK(TIMERS_RTCCALICFG2_REG(0), TIMERS_RTC_CALI_TIMEOUT)!=0)
		{
			CLEAR_PERI_REG_MASK(TIMERS_RTCCALICFG_REG(0),TIMERS_RTC_CALI_START);
			printinfo("timeout reset!\n",1);
			return 0;
		}
	}

	CLEAR_PERI_REG_MASK(TIMERS_RTCCALICFG_REG(0),TIMERS_RTC_CALI_START);
	u32 result = GET_PERI_REG_BITS(TIMERS_RTCCALICFG1_REG(0), TIMERS_RTC_CALI_VALUE, TIMERS_RTC_CALI_VALUE_S);
	u32 freq = 800000/result;
	return freq;
}

void rtc_clk_cali_cycling(u8 clk_sel, u32 period)
{
	SET_PERI_REG_BITS(TIMERS_RTCCALICFG_REG(0), TIMERS_RTC_CALI_CLK_SEL, clk_sel, TIMERS_RTC_CALI_CLK_SEL_S);
	SET_PERI_REG_BITS(TIMERS_RTCCALICFG_REG(0), TIMERS_RTC_CALI_MAX, period, TIMERS_RTC_CALI_MAX_S);
	CLEAR_PERI_REG_MASK(TIMERS_RTCCALICFG_REG(0), TIMERS_RTC_CALI_START_CYCLING);
	SET_PERI_REG_MASK(TIMERS_RTCCALICFG_REG(0), TIMERS_RTC_CALI_START_CYCLING);
}

void rtc_8m_en(u8 div)
{
	SET_PERI_REG_MASK(RTC_ANA_CONF, RTC_CNTL_CKGEN_I2C_PU);
	CLEAR_PERI_REG_MASK(RTC_CLK_CONF, RTC_CNTL_ENB_CK8M);
	CLEAR_PERI_REG_MASK(RTC_CLK_CONF,RTC_CNTL_CK8M_DIV_SEL_VLD); //clear vld
	SET_PERI_REG_BITS(RTC_CLK_CONF,RTC_CNTL_CK8M_DIV_SEL, div, RTC_CNTL_CK8M_DIV_SEL_S); //8mclk no div
	SET_PERI_REG_MASK(RTC_CLK_CONF,RTC_CNTL_CK8M_DIV_SEL_VLD); //set vld
}

void rtc_32k_en(bool init_clk)
{
	SET_PERI_REG_MASK(RTC_EXT_XTL_CONF, RTC_CNTL_XTAL32K_XPD_FORCE);
	SET_PERI_REG_MASK(RTC_EXT_XTL_CONF, RTC_CNTL_XPD_XTAL_32K);
	if (init_clk)
	{
		SET_PERI_REG_MASK(RTC_CLK_CONF, RTC_CNTL_DIG_CLK8M_EN);
		CLEAR_PERI_REG_MASK(SYSTEM_BT_LPCK_DIV_FRAC_REG, SYSTEM_LPCLK_SEL_8M);
		SET_PERI_REG_MASK(SYSTEM_BT_LPCK_DIV_FRAC_REG, SYSTEM_LPCLK_SEL_XTAL);
		SET_PERI_REG_BITS(SYSTEM_BT_LPCK_DIV_INT_REG, SYSTEM_BT_LPCK_DIV_NUM, 610, SYSTEM_BT_LPCK_DIV_NUM_S);
		SET_PERI_REG_BITS(SYSTEM_BT_LPCK_DIV_FRAC_REG, SYSTEM_BT_LPCK_DIV_A, 20, SYSTEM_BT_LPCK_DIV_A_S);
		SET_PERI_REG_BITS(SYSTEM_BT_LPCK_DIV_FRAC_REG, SYSTEM_BT_LPCK_DIV_B, 7, SYSTEM_BT_LPCK_DIV_B_S);
		SET_PERI_REG_MASK(SYSTEM_BT_LPCK_DIV_FRAC_REG, SYSTEM_LPCLK_RTC_EN);
		SET_PERI_REG_MASK(RTC_EXT_XTL_CONF, RTC_CNTL_ENCKINIT_XTAL_32K);
		CLEAR_PERI_REG_MASK(RTC_CLK_CONF, RTC_CNTL_DIG_CLK8M_EN);
	}
}

void rtc_32k_off()
{
	SET_PERI_REG_MASK(RTC_EXT_XTL_CONF, RTC_CNTL_XTAL32K_XPD_FORCE);
	CLEAR_PERI_REG_MASK(RTC_EXT_XTL_CONF, RTC_CNTL_XPD_XTAL_32K);
}

void rtc_slow_clk_delay()
{
	SET_PERI_REG_MASK(RTC_SLOW_CLK_CONF, RTC_CNTL_RTC_SLOW_CLK_NEXT_EDGE);
	while (1)
	{
		if (GET_PERI_REG_BITS(RTC_SLOW_CLK_CONF, 1, RTC_CNTL_RTC_SLOW_CLK_NEXT_EDGE_S) == 0x0) break;
	}
}

//sensor related
u32 rtc_tsens(u32 wait_delay, u32 clk_div, u32 meas_delay)
{
	int temp;
	SET_PERI_REG_MASK(SAR_TSENS_CTRL2, SAR_TSENS_CLKGATE_EN);
	//after tsens_pu, wait cycles = wait_delay, release reset
	SET_PERI_REG_BITS(SAR_TSENS_CTRL2, SAR_TSENS_XPD_WAIT, wait_delay, SAR_TSENS_XPD_WAIT_S);
	//tsens clk divider
	SET_PERI_REG_BITS(SAR_TSENS_CTRL, SAR_TSENS_CLK_DIV, clk_div, SAR_TSENS_CLK_DIV_S);
	//force start temp sensor
	CLEAR_PERI_REG_MASK(SAR_TSENS_CTRL, SAR_TSENS_DUMP_OUT);
	SET_PERI_REG_MASK(SAR_TSENS_CTRL, SAR_TSENS_POWER_UP_FORCE);
	SET_PERI_REG_MASK(SAR_TSENS_CTRL, SAR_TSENS_POWER_UP);
	//wait meas_delay us
	delay_us(meas_delay);
	//end tsens
	SET_PERI_REG_MASK(SAR_TSENS_CTRL, SAR_TSENS_DUMP_OUT);
	while(!GET_PERI_REG_MASK(SAR_TSENS_CTRL, SAR_TSENS_READY));
	temp = GET_PERI_REG_BITS(SAR_TSENS_CTRL, SAR_TSENS_OUT, SAR_TSENS_OUT_S);
	//reset settings
	CLEAR_PERI_REG_MASK(SAR_TSENS_CTRL, SAR_TSENS_POWER_UP);
	temp = ((temp - 86) * 5) >> 2;
	return temp;
}

u32 rtc_touch_read (u32 pad, u32 cnt, bool polling)
{
	SET_PERI_REG_BITS(RTC_TOUCH_SCAN_CTRL, RTC_CNTL_TOUCH_SCAN_PAD_MAP, 1<<pad, RTC_CNTL_TOUCH_SCAN_PAD_MAP_S);

	SET_PERI_REG_BITS(RTC_TOUCH_CTRL1, RTC_CNTL_TOUCH_MEAS_NUM, cnt, RTC_CNTL_TOUCH_MEAS_NUM_S);

	SET_PERI_REG_MASK(RTC_TOUCH_CTRL2, RTC_CNTL_TOUCH_START_FSM_EN);
	SET_PERI_REG_MASK(RTC_TOUCH_CTRL2, RTC_CNTL_TOUCH_START_FORCE);
	SET_PERI_REG_MASK(RTC_TOUCH_CTRL2, RTC_CNTL_TOUCH_START_EN);
	
	if (polling)
	{
		while(GET_PERI_REG_MASK(SAR_TOUCH_CHN_ST, SAR_TOUCH_MEAS_DONE)==0);
	}
	else
	{
		__asm__ ( "WAITI 0" );
	}

	u32 result = GET_PERI_REG_BITS(SAR_TOUCH_OUT0 + 4*pad, SAR_TOUCH_MEAS_OUT1, SAR_TOUCH_MEAS_OUT1_S);

	CLEAR_PERI_REG_MASK(RTC_TOUCH_CTRL2, RTC_CNTL_TOUCH_START_FORCE);
	CLEAR_PERI_REG_MASK(RTC_TOUCH_CTRL2, RTC_CNTL_TOUCH_START_EN);
	return result;
}

u32 rtc_saradc1(u8 chn, u8 div)
{
	SET_PERI_REG_MASK(SAR_MEAS1_CTRL2, SAR_SAR1_EN_PAD_FORCE);
	SET_PERI_REG_BITS(SAR_MEAS1_CTRL2, SAR_SAR1_EN_PAD, 1 << chn, SAR_SAR1_EN_PAD_S);
	SET_PERI_REG_BITS(SAR_POWER_XPD_SAR, SAR_FORCE_XPD_SAR, 0, SAR_FORCE_XPD_SAR_S);
	SET_PERI_REG_BITS(SAR_READER1_CTRL, SAR_SAR1_CLK_DIV, div, SAR_SAR1_CLK_DIV_S);
	SET_PERI_REG_MASK(SAR_MEAS1_CTRL2, SAR_MEAS1_START_FORCE);
	SET_PERI_REG_MASK(SAR_MEAS1_CTRL2, SAR_MEAS1_START_SAR);

	while(GET_PERI_REG_MASK(SAR_MEAS1_CTRL2, SAR_MEAS1_DONE_SAR)==0);
	u32 result = GET_PERI_REG_MASK(SAR_MEAS1_CTRL2, SAR_MEAS1_DATA_SAR);

	CLEAR_PERI_REG_MASK(SAR_MEAS1_CTRL2, SAR_MEAS1_START_FORCE);
	CLEAR_PERI_REG_MASK(SAR_MEAS1_CTRL2, SAR_MEAS1_START_SAR);
	return result;
}

u32 rtc_saradc2(u8 chn, u8 div)
{
	SET_PERI_REG_MASK(SAR_MEAS2_CTRL2, SAR_SAR2_EN_PAD_FORCE);
	SET_PERI_REG_BITS(SAR_MEAS2_CTRL2, SAR_SAR2_EN_PAD, 1 << chn, SAR_SAR1_EN_PAD_S);
	SET_PERI_REG_BITS(SAR_POWER_XPD_SAR, SAR_FORCE_XPD_SAR, 0, SAR_FORCE_XPD_SAR_S);
	SET_PERI_REG_BITS(SAR_READER2_CTRL, SAR_SAR2_CLK_DIV, div, SAR_SAR2_CLK_DIV_S);
	SET_PERI_REG_MASK(SAR_MEAS2_CTRL2, SAR_MEAS2_START_FORCE);
	SET_PERI_REG_MASK(SAR_MEAS2_CTRL2, SAR_MEAS2_START_SAR);

	while(GET_PERI_REG_MASK(SAR_MEAS2_CTRL2, SAR_MEAS2_DONE_SAR)==0);
	u32 result = GET_PERI_REG_MASK(SAR_MEAS2_CTRL2, SAR_MEAS2_DATA_SAR);

	CLEAR_PERI_REG_MASK(SAR_MEAS2_CTRL2, SAR_MEAS2_START_FORCE);
	CLEAR_PERI_REG_MASK(SAR_MEAS2_CTRL2, SAR_MEAS2_START_SAR);
	return result;
}

u32 rtc_vdd33()
{
	SET_PERI_REG_MASK(SAR_MEAS2_CTRL2, SAR_SAR2_EN_PAD_FORCE);
	SET_PERI_REG_BITS(SAR_MEAS2_CTRL2, SAR_SAR2_EN_PAD, 0, SAR_SAR1_EN_PAD_S);
	SET_PERI_REG_BITS(I2C_MST_ANA_CONF4_REG, 0xFF, 1, 8);
	SET_PERI_REG_MASK(SAR_MEAS2_CTRL1, SAR_SAR2_EN_TEST);
	SET_PERI_REG_MASK(SAR_MEAS2_CTRL1, SAR_SAR2_PKDET_CAL_EN);
	SET_PERI_REG_MASK(SAR_MEAS2_CTRL1, SAR_SAR2_PWDET_CAL_EN);
	SET_PERI_REG_MASK(SAR_MEAS2_CTRL2, SAR_MEAS2_START_FORCE);
	SET_PERI_REG_MASK(SAR_MEAS2_CTRL2, SAR_MEAS2_START_SAR);

	while(GET_PERI_REG_MASK(SAR_MEAS2_CTRL2, SAR_MEAS2_DONE_SAR)==0);
	u32 result = GET_PERI_REG_MASK(SAR_MEAS2_CTRL2, SAR_MEAS2_DATA_SAR);

	CLEAR_PERI_REG_MASK(SAR_MEAS2_CTRL2, SAR_MEAS2_START_FORCE);
	CLEAR_PERI_REG_MASK(SAR_MEAS2_CTRL2, SAR_MEAS2_START_SAR);
	CLEAR_PERI_REG_MASK(SAR_MEAS2_CTRL1, SAR_SAR2_EN_TEST);
	CLEAR_PERI_REG_MASK(SAR_MEAS2_CTRL1, SAR_SAR2_PKDET_CAL_EN);
	CLEAR_PERI_REG_MASK(SAR_MEAS2_CTRL1, SAR_SAR2_PWDET_CAL_EN);
	return result;
}

#define PWDET_CONF0	I2C_MST_ANA_CONF4_REG
#define PWDET_CONF1	I2C_MST_ANA_CONF5_REG
#define PWDET_CONF2	I2C_MST_ANA_CONF6_REG
#define PWDET_CONF3	I2C_MST_ANA_CONF7_REG
#define PWDET_CONF4	I2C_MST_ANA_CONF8_REG
void get_vdd33(u8 sample_num)
{
	CLEAR_PERI_REG_MASK(PWDET_CONF0, (BIT(0)));
	SET_PERI_REG_BITS(PWDET_CONF4, 0xFF, 20, 16); //wait xpd
	SET_PERI_REG_MASK(PWDET_CONF3, (BIT(23))); //pkdet
	SET_PERI_REG_BITS(PWDET_CONF4, 0x3, 3, 5); //bit width
	SET_PERI_REG_BITS(PWDET_CONF0, 0x3, 3, 6); //sample bit
	SET_PERI_REG_BITS(PWDET_CONF0, 0x7, sample_num, 2); //sample num

	SET_PERI_REG_MASK(PWDET_CONF0, (BIT(1))); //start

	while (1)
	{
		if (GET_PERI_REG_BITS(PWDET_CONF0, 0x7, 24)==0x7) break;
	}
	CLEAR_PERI_REG_MASK(PWDET_CONF0, (BIT(1))); //clear start
}

//ulp related
void rtc_check_ulp_done()
{
	while (1)
	{
		if (GET_PERI_REG_BITS(RTC_LOW_POWER_ST, 1, RTC_CNTL_RTC_COCPU_STATE_DONE_S)==1) break;
	}
}

//cpu interrupt 
void interrupt_enable(unsigned int inum, void * interrupt_handler)
{
	_xtos_set_interrupt_handler_arg(inum, interrupt_handler, 0);
	_xtos_ints_on(1 << inum);
}

void interrupt_disable(unsigned int inum)
{
	_xtos_ints_off(1 << inum);
}

u32 i2c_ana_rd(unsigned int host_addr, unsigned int mst_id, unsigned int addr, unsigned int byte_bit)
{
   unsigned int const mst_num = 0;
   unsigned int value;
   unsigned int* mst_ctrl_addr;
   mst_ctrl_addr = (unsigned int*) (host_addr + mst_num *4);
   value = (0<<24) | (0 << 16) | (addr <<8) | mst_id;
   *(volatile unsigned int*) mst_ctrl_addr = value;
   while(((*(volatile unsigned int*) mst_ctrl_addr ) & 0x2000000) != 0){};
   value = ((*(volatile unsigned int*) mst_ctrl_addr) >> 16) & 0xff & byte_bit;
   return value;
}

void i2c_ana_wr(unsigned int host_addr, unsigned int mst_id, unsigned int addr, unsigned int data, unsigned int byte_bit)
{
   unsigned int const mst_num = 0;
   unsigned int value;
   unsigned int* mst_ctrl_addr;
   unsigned int temp_data;

   value = i2c_ana_rd(host_addr, mst_id, addr, 0xff);
   temp_data = value & (~byte_bit) | data;

   mst_ctrl_addr = (unsigned int*) (host_addr + mst_num *4);
   value = (1<<24) | (temp_data << 16) | (addr <<8) | mst_id;
   *(volatile unsigned int*) mst_ctrl_addr = value;
   while(((*(volatile unsigned int*) mst_ctrl_addr ) & 0x2000000) != 0){};
}

#define BROWNOUT_SET(thres)	i2c_ana_wr(REG_I2C_BASE+4, I2C_ULP_BLOCK, 5, thres, 0xFF)
